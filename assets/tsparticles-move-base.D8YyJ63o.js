import{g as i,I as e,c as t,l as n,D as a,n as o}from"./tsparticles-engine.CajW4cSt.js";function s(i,e,n,a,o,s){!function(i,e){const n=i.options,a=n.move.path;if(!a.enable)return;if(i.lastPathTime<=i.pathDelay)return void(i.lastPathTime+=e.value);const o=i.pathGenerator?.generate(i,e);o&&i.velocity.addTo(o);a.clamp&&(i.velocity.x=t(i.velocity.x,-1,1),i.velocity.y=t(i.velocity.y,-1,1));i.lastPathTime-=i.pathDelay}(i,s);const c=i.gravity,r=c?.enable&&c.inverse?-1:1;o&&n&&(i.velocity.x+=o*s.factor/(60*n)),c?.enable&&n&&(i.velocity.y+=r*(c.acceleration*s.factor)/(60*n));const l=i.moveDecay;i.velocity.multTo(l);const y=i.velocity.mult(n);c?.enable&&a>0&&(!c.inverse&&y.y>=0&&y.y>=a||c.inverse&&y.y<=0&&y.y<=-a)&&(y.y=r*a,n&&(i.velocity.y=y.y/n));const p=i.options.zIndex,v=(1-i.zIndexFactor)**p.velocityRate;y.multTo(v);const{position:d}=i;d.addTo(y),e.vibrate&&(d.x+=Math.sin(d.x*Math.cos(d.y)),d.y+=Math.cos(d.y*Math.sin(d.x)))}class c{constructor(){this._initSpin=i=>{const e=i.container,t=i.options.move.spin;if(!t.enable)return;const o=t.position??{x:50,y:50},s={x:o.x/100*e.canvas.size.width,y:o.y/100*e.canvas.size.height},c=i.getPosition(),r=n(c,s),l=a(t.acceleration);i.retina.spinAcceleration=l*e.retina.pixelRatio,i.spin={center:s,direction:i.velocity.x>=0?"clockwise":"counter-clockwise",angle:i.velocity.angle,radius:r,acceleration:i.retina.spinAcceleration}}}init(i){const e=i.options.move.gravity;i.gravity={enable:e.enable,acceleration:a(e.acceleration),inverse:e.inverse},this._initSpin(i)}isEnabled(i){return!i.destroyed&&i.options.move.enable}move(t,n){const c=t.options,r=c.move;if(!r.enable)return;const l=t.container,y=l.retina.pixelRatio,p=function(i){return i.slow.inRange?i.slow.factor:1}(t),v=(t.retina.moveSpeed??=a(r.speed)*y)*l.retina.reduceFactor,d=t.retina.moveDrift??=a(t.options.move.drift)*y,x=o(c.size.value)*y,u=v*(r.size?t.getRadius()/x:1)*p*(n.factor||1)/2,m=t.retina.maxSpeed??l.retina.maxSpeed;r.spin.enable?function(i,e){const t=i.container;if(!i.spin)return;const n={x:"clockwise"===i.spin.direction?Math.cos:Math.sin,y:"clockwise"===i.spin.direction?Math.sin:Math.cos};i.position.x=i.spin.center.x+i.spin.radius*n.x(i.spin.angle),i.position.y=i.spin.center.y+i.spin.radius*n.y(i.spin.angle),i.spin.radius+=i.spin.acceleration;const a=Math.max(t.canvas.size.width,t.canvas.size.height);i.spin.radius>a/2?(i.spin.radius=a/2,i.spin.acceleration*=-1):i.spin.radius<0&&(i.spin.radius=0,i.spin.acceleration*=-1),i.spin.angle+=e/100*(1-i.spin.radius/a)}(t,u):s(t,r,u,m,d,n),function(t){const n=t.initialPosition,{dx:a,dy:o}=i(n,t.position),s=Math.abs(a),c=Math.abs(o),{maxDistance:r}=t.retina,l=r.horizontal,y=r.vertical;if(l||y)if((l&&s>=l||y&&c>=y)&&!t.misplaced)t.misplaced=!!l&&s>l||!!y&&c>y,l&&(t.velocity.x=t.velocity.y/2-t.velocity.x),y&&(t.velocity.y=t.velocity.x/2-t.velocity.y);else if((!l||s<l)&&(!y||c<y)&&t.misplaced)t.misplaced=!1;else if(t.misplaced){const i=t.position,a=t.velocity;l&&(i.x<n.x&&a.x<0||i.x>n.x&&a.x>0)&&(a.x*=-e()),y&&(i.y<n.y&&a.y<0||i.y>n.y&&a.y>0)&&(a.y*=-e())}}(t)}}async function r(i,e=!0){await i.addMover("base",(()=>new c),e)}export{r as l};
