import{g as k,I as R,c as S,l as I,D as z,n as A}from"./tsparticles-engine-B56Pkamw.js";function F(i,n,o,s,c,r){(function(t,g){var u;const e=t.options,y=e.move.path;if(!y.enable)return;if(t.lastPathTime<=t.pathDelay)return void(t.lastPathTime+=g.value);const x=(u=t.pathGenerator)==null?void 0:u.generate(t,g);x&&t.velocity.addTo(x),y.clamp&&(t.velocity.x=S(t.velocity.x,-1,1),t.velocity.y=S(t.velocity.y,-1,1)),t.lastPathTime-=t.pathDelay})(i,r);const a=i.gravity,h=a!=null&&a.enable&&a.inverse?-1:1;c&&o&&(i.velocity.x+=c*r.factor/(60*o)),a!=null&&a.enable&&o&&(i.velocity.y+=h*(a.acceleration*r.factor)/(60*o));const b=i.moveDecay;i.velocity.multTo(b);const l=i.velocity.mult(o);a!=null&&a.enable&&s>0&&(!a.inverse&&l.y>=0&&l.y>=s||a.inverse&&l.y<=0&&l.y<=-s)&&(l.y=h*s,o&&(i.velocity.y=l.y/o));const T=i.options.zIndex,M=(1-i.zIndexFactor)**T.velocityRate;l.multTo(M);const{position:p}=i;p.addTo(l),n.vibrate&&(p.x+=Math.sin(p.x*Math.cos(p.y)),p.y+=Math.cos(p.y*Math.sin(p.x)))}class _{constructor(){this._initSpin=n=>{const o=n.container,s=n.options.move.spin;if(!s.enable)return;const c=s.position??{x:50,y:50},r={x:c.x/100*o.canvas.size.width,y:c.y/100*o.canvas.size.height},a=n.getPosition(),h=I(a,r),b=z(s.acceleration);n.retina.spinAcceleration=b*o.retina.pixelRatio,n.spin={center:r,direction:n.velocity.x>=0?"clockwise":"counter-clockwise",angle:n.velocity.angle,radius:h,acceleration:n.retina.spinAcceleration}}}init(n){const o=n.options.move.gravity;n.gravity={enable:o.enable,acceleration:z(o.acceleration),inverse:o.inverse},this._initSpin(n)}isEnabled(n){return!n.destroyed&&n.options.move.enable}move(n,o){var t,g;const s=n.options,c=s.move;if(!c.enable)return;const r=n.container,a=r.retina.pixelRatio,h=function(e){return e.slow.inRange?e.slow.factor:1}(n),b=((t=n.retina).moveSpeed??(t.moveSpeed=z(c.speed)*a))*r.retina.reduceFactor,l=(g=n.retina).moveDrift??(g.moveDrift=z(n.options.move.drift)*a),T=A(s.size.value)*a,M=b*(c.size?n.getRadius()/T:1)*h*(o.factor||1)/2,p=n.retina.maxSpeed??r.retina.maxSpeed;c.spin.enable?function(e,y){const x=e.container;if(!e.spin)return;const u={x:e.spin.direction==="clockwise"?Math.cos:Math.sin,y:e.spin.direction==="clockwise"?Math.sin:Math.cos};e.position.x=e.spin.center.x+e.spin.radius*u.x(e.spin.angle),e.position.y=e.spin.center.y+e.spin.radius*u.y(e.spin.angle),e.spin.radius+=e.spin.acceleration;const m=Math.max(x.canvas.size.width,x.canvas.size.height);e.spin.radius>m/2?(e.spin.radius=m/2,e.spin.acceleration*=-1):e.spin.radius<0&&(e.spin.radius=0,e.spin.acceleration*=-1),e.spin.angle+=y/100*(1-e.spin.radius/m)}(n,M):F(n,c,M,p,l,o),function(e){const y=e.initialPosition,{dx:x,dy:u}=k(y,e.position),m=Math.abs(x),D=Math.abs(u),{maxDistance:P}=e.retina,v=P.horizontal,d=P.vertical;if(v||d){if((v&&m>=v||d&&D>=d)&&!e.misplaced)e.misplaced=!!v&&m>v||!!d&&D>d,v&&(e.velocity.x=e.velocity.y/2-e.velocity.x),d&&(e.velocity.y=e.velocity.x/2-e.velocity.y);else if((!v||m<v)&&(!d||D<d)&&e.misplaced)e.misplaced=!1;else if(e.misplaced){const w=e.position,f=e.velocity;v&&(w.x<y.x&&f.x<0||w.x>y.x&&f.x>0)&&(f.x*=-R()),d&&(w.y<y.y&&f.y<0||w.y>y.y&&f.y>0)&&(f.y*=-R())}}}(n)}}async function G(i,n=!0){await i.addMover("base",()=>new _,n)}export{G as l};
