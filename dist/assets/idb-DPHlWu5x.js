let g,m;const b=new WeakMap,v=new WeakMap,y=new WeakMap,p=new WeakMap,D=new WeakMap;let I={get(e,n,t){if(e instanceof IDBTransaction){if(n==="done")return v.get(e);if(n==="objectStoreNames")return e.objectStoreNames||y.get(e);if(n==="store")return t.objectStoreNames[1]?void 0:t.objectStore(t.objectStoreNames[0])}return u(e[n])},set:(e,n,t)=>(e[n]=t,!0),has:(e,n)=>e instanceof IDBTransaction&&(n==="done"||n==="store")||n in e};function E(e){return e!==IDBDatabase.prototype.transaction||"objectStoreNames"in IDBTransaction.prototype?(m||(m=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])).includes(e)?function(...n){return e.apply(f(this),n),u(b.get(this))}:function(...n){return u(e.apply(f(this),n))}:function(n,...t){const o=e.call(f(this),n,...t);return y.set(o,n.sort?n.sort():[n]),u(o)}}function h(e){return typeof e=="function"?E(e):(e instanceof IDBTransaction&&function(t){if(v.has(t))return;const o=new Promise((s,c)=>{const a=()=>{t.removeEventListener("complete",i),t.removeEventListener("error",r),t.removeEventListener("abort",r)},i=()=>{s(),a()},r=()=>{c(t.error||new DOMException("AbortError","AbortError")),a()};t.addEventListener("complete",i),t.addEventListener("error",r),t.addEventListener("abort",r)});v.set(t,o)}(e),n=e,(g||(g=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])).some(t=>n instanceof t)?new Proxy(e,I):e);var n}function u(e){if(e instanceof IDBRequest)return function(t){const o=new Promise((s,c)=>{const a=()=>{t.removeEventListener("success",i),t.removeEventListener("error",r)},i=()=>{s(u(t.result)),a()},r=()=>{c(t.error),a()};t.addEventListener("success",i),t.addEventListener("error",r)});return o.then(s=>{s instanceof IDBCursor&&b.set(s,t)}).catch(()=>{}),D.set(o,t),o}(e);if(p.has(e))return p.get(e);const n=h(e);return n!==e&&(p.set(e,n),D.set(n,e)),n}const f=e=>D.get(e);function j(e,n,{blocked:t,upgrade:o,blocking:s,terminated:c}={}){const a=indexedDB.open(e,n),i=u(a);return o&&a.addEventListener("upgradeneeded",r=>{o(u(a.result),r.oldVersion,r.newVersion,u(a.transaction),r)}),t&&a.addEventListener("blocked",r=>t(r.oldVersion,r.newVersion,r)),i.then(r=>{c&&r.addEventListener("close",()=>c()),s&&r.addEventListener("versionchange",d=>s(d.oldVersion,d.newVersion,d))}).catch(()=>{}),i}const w=["get","getKey","getAll","getAllKeys","count"],L=["put","add","delete","clear"],l=new Map;function B(e,n){if(!(e instanceof IDBDatabase)||n in e||typeof n!="string")return;if(l.get(n))return l.get(n);const t=n.replace(/FromIndex$/,""),o=n!==t,s=L.includes(t);if(!(t in(o?IDBIndex:IDBObjectStore).prototype)||!s&&!w.includes(t))return;const c=async function(a,...i){const r=this.transaction(a,s?"readwrite":"readonly");let d=r.store;return o&&(d=d.index(i.shift())),(await Promise.all([d[t](...i),s&&r.done]))[0]};return l.set(n,c),c}I=(e=>({...e,get:(n,t,o)=>B(n,t)||e.get(n,t,o),has:(n,t)=>!!B(n,t)||e.has(n,t)}))(I);export{j as o};
